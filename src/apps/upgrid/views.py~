#System lib
from django.shortcuts import render, render_to_response, get_object_or_404
from django.http import HttpResponse, HttpResponseRedirect, Http404
from django.contrib.auth.models import Group
from django.template.context import RequestContext
from django.template.loader import render_to_string
from django.conf import settings
from django.core.mail import send_mail, BadHeaderError, EmailMessage
from django.utils.translation import ugettext, ugettext_lazy as _
from django.db.models import Q
import base64
from django.contrib.auth import authenticate
#3rd party lib
from rest_framework.filters import SearchFilter, OrderingFilter
from rest_framework.status import *
from rest_framework.decorators import api_view, permission_classes
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import generics, status
from rest_framework.permissions import IsAuthenticatedOrReadOnly, IsAuthenticated, AllowAny
from rest_framework_jwt.views import ObtainJSONWebToken
from rest_framework_jwt.settings import api_settings
jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER
from guardian.shortcuts import assign_perm, remove_perm
from guardian.decorators import permission_required_or_403
from weasyprint import HTML, CSS
import weasyprint

#Our lib
from ceeb_program.models import *

#lib in same project
from apps.upgrid.pagination import CustomerLimitOffsetPagination, CustomerPageNumberPagination
from apps.upgrid.models import *
from apps.upgrid.serializers import *
from django.dispatch import receiver
from django.db.models.signals import post_save, pre_save
from django.core.mail import EmailMessage
from django.conf import settings
import django.utils.timezone as timezone


class UnivCustomerDetail(APIView):
    #permission_classes = ((IsAuthenticated,))


    def post(self, request, format=None):
        customeremail = request.data['email']
        customer = UniversityCustomer.objects.get(login_email = customeremail)
        serializer = UnivCustomerSerializer(customer)
        return Response(data = serializer.data)


class Selected_Program(generics.ListAPIView):
    """
    Get customer's selected program
    """
    serializer_class = UnivCustomerProgramSerializer
    permission_classes = ((AllowAny,))
    pagination_class = CustomerPageNumberPagination


    def get_queryset(self, *args, **kwargs):
        programname = self.request.GET.get("name")
        programdegree = self.request.GET.get("degree")
        finalrelease_status = self.request.GET.get("fs")
        confirmationstatus =self.request.GET.get("cs")
        order = self.request.GET.get("order")

        if order == "oname":
            order = 'program__program_name'

        elif order == "-oname":
            order = '-program__program_name'

        elif order == "degree":
            order = 'program__degree__name'

        elif order == "-degree":
            order = '-program__degree__name'

        elif order == 'cs':
            order = 'customerconfirmation_status'

        elif order == '-cs':
            order = '-customerconfirmation_status'

        elif order == 'fs':
            order = 'finalrelease_status'

        elif order == '-fs':
            order = '-finalrelease_status'

        if not self.request.user.is_anonymous:
            mainUser = UniversityCustomer.objects.get(username = self.request.user.username)
            #mainUser = UniversityCustomer.objects.get(username = 'test_columbia@M')
            if mainUser.account_type == 'Sub':
                mainUser =  UniversityCustomer.objects.get(account_type='main', Ceeb=mainUser.Ceeb)

            query_list = UniversityCustomerProgram.objects.filter(customer = mainUser).order_by(order)
            if programname:
                query_list = query_list.filter(
                    Q(program__program_name__icontains = programname)
                    ).order_by(order)
            if programdegree:
                query_list = query_list.filter(
                    Q(program__degree__name__icontains = programdegree)
                    ).order_by(order)
            if finalrelease_status:
                query_list = query_list.filter(
                    Q(finalrelease_status= finalrelease_status)
                    ).order_by(order)
            if confirmationstatus:
                query_list = query_list.filter(
                    Q(customerconfirmation_status = confirmationstatus)
                    ).order_by(order)
            return query_list
        else:
            return []


class ConfirmationStatusDetail(generics.UpdateAPIView):

    permission_classes = ((IsAuthenticated,))
    queryset = UniversityCustomerProgram.objects.all()
    serializer_class = ConfirmationStatusSerializer
    lookup_field = 'object_id'


class IsActiveAPI(generics.UpdateAPIView):
    queryset = UniversityCustomer.objects.all()
    serializer_class = IsActiveSerializer
    lookup_field = 'username'



class CreateSubUserView(generics.GenericAPIView):

    def validate(self, data):
        decoded_string = base64.b64decode(data)
        return decoded_string


    def post(self, request, format=None):
        mainUser = UniversityCustomer.objects.get(username=self.request.user.username)
        newservice_until = mainUser.service_until
        universityschool = UniversitySchool.objects.get(ceeb = self.request.data['Ceeb'])
        user = UniversityCustomer.objects.create(
            username = self.request.data['username'],
            login_email = self.request.data['email'],
            Ceeb = universityschool,
            contract_prefix = self.request.data['contract_prefix'],
            contract_name = self.request.data['contract_name'],
            contract_title = self.request.data['contract_title'],
            contract_level = self.request.data['contract_level'],
            contract_tel = self.request.data['contract_tel'],
            service_until = newservice_until)

        decoded_newpwd = self.validate(self.request.data['password'])
        user.set_password(decoded_newpwd)
        user.save()
        return Response({"success": _("New user has been created.")})


@api_view()
@permission_classes((IsAuthenticated,))
def FindSubUser(request):
    try:
        mainUser = UniversityCustomer.objects.get(username=request.user.username)
        mainceeb = mainUser.Ceeb.ceeb
        groupName = 'Sub' + mainceeb
        subUser = UniversityCustomer.objects.filter(groups__name=groupName, is_active=True)
        res = FindSubUserSerializer(subUser, many=True)
        return Response(res.data)
    except UniversityCustomer.DoesNotExist:
        return HttpResponse('The User DoesNotExist')


@api_view()
@permission_classes((IsAuthenticated,))
def mainUserInfo(request):
    if request.user.is_anonymous:
        return HttpResponse('The Requesting User DoesNotExist', status=HTTP_403_FORBIDDEN)
    else:
        subuser = request.user
        mainuser = UniversityCustomer.objects.get(Ceeb=subuser.Ceeb, account_type='main')
        res = mainUserInfoSerializer(mainuser)
        return Response(res.data)


@api_view(['POST'])
@permission_classes((IsAuthenticated,))
def EnhancementPermissions(request):
    if request.method == 'POST':
        mainUser = UniversityCustomer.objects.get(login_email=request.data['email'])
        mainUserceeb = mainUser.Ceeb.ceeb
        PrimaryGroup, created = Group.objects.get_or_create(name='Primary'+mainUserceeb)
        SubGroup, created = Group.objects.get_or_create(name='Sub'+mainUserceeb)

        mainCustomerProgram = UniversityCustomerProgram.objects.filter(customer= mainUser)
        for p in mainCustomerProgram:
            if p.customerconfirmation_status == 'Yes':
                assign_perm('ceeb_program.view_only_program', SubGroup, p.program)
                assign_perm('ceeb_program.view_only_program', PrimaryGroup, p.program)
                competingProgram = Competing_Program.objects.filter(customer_program=p.object_id)
                for cp in competingProgram:
                    assign_perm('ceeb_program.view_only_program', SubGroup, cp.program)
                    assign_perm('ceeb_program.view_only_program', PrimaryGroup, cp.program)
        return Response("Set Permission Success")           


@api_view(['POST'])
@permission_classes((IsAuthenticated,))
def WhoopsPermissions(request):
    if request.method == 'POST':
        mainUser = UniversityCustomer.objects.get(login_email=request.data['email'])
        mainUserceeb = mainUser.Ceeb.ceeb
        PrimaryGroup, created = Group.objects.get_or_create(name='Primary'+mainUserceeb)
        SubGroup, created = Group.objects.get_or_create(name='Sub'+mainUserceeb)

        mainCustomerProgram = UniversityCustomerProgram.objects.filter(customer=mainUser)
        for p in mainCustomerProgram:
            ean = ExpertAdditionalNote.objects.filter(program=p.program)

            for e in ean:
                assign_perm('ceeb_program.view_only_expertadditionalnote', SubGroup, e)
                assign_perm('ceeb_program.view_only_expertadditionalnote', PrimaryGroup, e)         
        return Response("OK")


@api_view()
@permission_classes((IsAuthenticated,))
def SubUserNum(request):
    mainUser = UniversityCustomer.objects.get(username=request.user.username)
    if not mainUser.account_type == 'main':
        return HttpResponse(status=HTTP_403_FORBIDDEN)
    elif not request.user.username == mainUser.username:
        return HttpResponse(status=HTTP_403_FORBIDDEN)
    mainUserceeb = mainUser.Ceeb.ceeb
    SubGroup='Sub'+mainUserceeb
    Users = UniversityCustomer.objects.filter(groups=Group.objects.get(name=SubGroup))
    return Response(len(Users))


class CustomizeJWT(ObtainJSONWebToken):
    serializer_class = Login2Serializer

"""
test view
"""


class UniversityDetail(APIView):
    permission_classes = ((IsAuthenticated,))
    def get_object(self, ceeb):
        try:
            return UniversitySchool.objects.get(ceeb=ceeb)
        except UniversitySchool.DoesNotExist:
            raise Http404


    def post(self, request, format=None):
        Ceeb = request.data['Ceeb']
        university = self.get_object(Ceeb)
        serializer = UniversitySerializer(university)
        return Response(serializer.data)




@api_view(['POST'])
@permission_classes((IsAuthenticated,))
def get_enhancement(request):
    if request.method == 'POST':
            User = request.user
            Total_Program = request.data['object_id'].split('/')
            print (Total_Program)
            for p in Total_Program:
                program = get_object_or_404(Program, object_id=p)
                if not User.has_perm('ceeb_program.view_only_program', program):
                    return HttpResponse(status= HTTP_403_FORBIDDEN)


            length = len(Total_Program)
            res_obj={}
            for i in range(1,length+1):
                program = "p"+ (str(i) if i>1 else "")
                curriculum = "c"+ (str(i) if i>1 else "")
                tuition = "t"+ (str(i) if i>1 else "")
                deadline = "d"+ (str(i) if i>1 else "")
                requirement = "r"+ (str(i) if i>1 else "")
                required_exam = "ex"+ (str(i) if i>1 else "")
                Intl_transcript = "Intl_transcript"+ (str(i) if i>1 else "")
                Intl_eng_test = "Intl_eng_test"+ (str(i) if i>1 else "")
                scholarship = "s"+ (str(i) if i>1 else "")
                duration = "dura" + (str(i) if i>1 else "")

                p_value = get_object_or_404(Program, object_id=Total_Program[i-1])
                c_value, created = Curriculum.objects.get_or_create(program=Program.objects.get(object_id=Total_Program[i-1]),)
                t_value, created = Tuition.objects.get_or_create(program=Program.objects.get(object_id=Total_Program[i-1]),)
                d_value, created = Deadline.objects.get_or_create(program=Program.objects.get(object_id=Total_Program[i-1]),)
                r_value, created = Requirement.objects.get_or_create(program=Program.objects.get(object_id=Total_Program[i-1]),)
                dura_value, created = Duration.objects.get_or_create(program=Program.objects.get(object_id=Total_Program[i-1]),)

                r_e_value = r_value.exam.all()
                i_value = r_value.intl_transcript.all()
                i_e_t_value = r_value.intl_english_test.all()
                s_value, created = Scholarship.objects.get_or_create(program=Program.objects.get(object_id=Total_Program[i-1]),)

                res_obj[program] = p_value
                res_obj[curriculum] = c_value
                res_obj[tuition] = t_value
                res_obj[deadline] = d_value
                res_obj[requirement] = r_value
                res_obj[required_exam] = r_e_value
                res_obj[Intl_transcript] = i_value
                res_obj[Intl_eng_test] = i_e_t_value
                res_obj[scholarship] = s_value
                res_obj[duration] = dura_value 

            res_obj["length"]=length

            html = render_to_string('enhancement/enhancement_5.html',res_obj)
            response = HttpResponse(content_type='application/pdf')
            response['Content-Disposition'] = 'filename="report.pdf"'
            weasyprint.HTML(string=html).write_pdf(response)
            return response



@api_view(['POST'])
@permission_classes((IsAuthenticated,))
def get_whoops(request):
    if request.method == 'POST':
        program = get_object_or_404(Program, object_id=request.data['object_id'])
        User = request.user
        ean = ExpertAdditionalNote.objects.filter(program=program)
        for e in ean:
            if not User.has_perm('ceeb_program.view_only_expertadditionalnote', e):
                return HttpResponse(status=HTTP_403_FORBIDDEN)

        if len(ean) == 0:

            try:
                ean = ExpertAdditionalNote.objects.get(program=program)
            except ExpertAdditionalNote.DoesNotExist:
                return HttpResponse(content_type = 'application/pdf', status =HTTP_204_NO_CONTENT)


        deadlink = ean.filter(additional_note_type = "dead_link")
        typo = ean.filter(additional_note_type = "typo")
        outdated_information = ean.filter(additional_note_type = "outdated_information")
        data_discrepancy = ean.filter(additional_note_type = "data_discrepancy")
        sidebars = ean.filter(additional_note_type = "sidebars")
        infinite_loop = ean.filter(additional_note_type = "infinite_loop")
        floating_page = ean.filter(additional_note_type = "floating_page")
        confusing = ean.filter(additional_note_type = "confusing")
        others = ean.filter(additional_note_type = "other_expert_note")
    
        html = render_to_string('whoops/whoops_report.html', {'deadlink': deadlink, 'typo': typo,
            'outdated_information': outdated_information, 'data_discrepancy': data_discrepancy,
            'sidebars': sidebars, 'infinite_loop': infinite_loop, 'floating_page': floating_page,
            'confusing': confusing, 'others': others})

        response = HttpResponse(content_type = 'application/pdf')
        response['Content-Disposition'] = 'filename="whoops_report.pdf"'
        weasyprint.HTML(string=html).write_pdf(response)

        return response



@permission_classes((IsAuthenticated,))
class ResetPasswordAPIView(APIView):

    def validate(self, data):
        decoded_string = base64.b64decode(data)
        return decoded_string

    def put(self, request, format=None):
        user = request.user
        encoded_password = request.data['password']
        password = self.validate(encoded_password)
        user.set_password(password)
        user.save()
        return Response({"success": _("New password has been saved.")})



@permission_classes((IsAuthenticated,))
class PasswordChangeView(generics.GenericAPIView):
    

    def validate_oldpwd(self, old_password):
        decoded_oldpwd = base64.b64decode(old_password)
        return decoded_oldpwd

    def validate_newpwd(self, new_password):
        decoded_newpwd = base64.b64decode(new_password)
        return decoded_newpwd

    def post(self, request, format=None):
        username = request.user.username
        if username:
            decoded_oldpwd = self.validate_oldpwd(request.data['old_password'])
            User = (authenticate(username=username, password=decoded_oldpwd))
            if User:
                decoded_newpwd = self.validate_newpwd(request.data['new_password'])

                User.set_password(decoded_newpwd)
                User.save()
                return Response({"success": _("New password has been saved.")})
            return Response({"Failed": _("Old password not correct.")})
        return Response({"Failed": _("Anonymous user can not change password")})        



@api_view(['POST',])
@permission_classes((AllowAny,))
def reset_password(request):
    if request.method == 'POST':
        text = "Password Reset email has been send! If you do not receive reset email within the next 5 minutes,"
        "please check your email address if it has registered."
        try:
            user_reset = UniversityCustomer.objects.get(login_email=request.data['email'])
        except UniversityCustomer.DoesNotExist:
            return HttpResponse(text,HTTP_200_OK)
        if user_reset:
            payload = jwt_payload_handler(user_reset)
            token = jwt_encode_handler(payload)

            if token:
                try:
                    username = user_reset.username
                    html_content = ("Hello, %s! <br>You're receiving this email"
                    "because you requested a password reset for your user account"
                    "at Upgrid!<br>Please go to the following page and choose a new"
                    "password: http://%s/static/angular-seed/app/index.html#/upgrid/reset/%s/%s/.<br>")
                    message = EmailMessage(subject='Reset Password', body=html_content %(user_reset.contract_name,
                        request.META['HTTP_HOST'], username, token), to=[request.data['email']])
                    message.content_subtype = 'html'
                    message.send()
                except BadHeaderError:
                    return HttpResponse(text, status=HTTP_200_OK)
                return HttpResponse(text, status=HTTP_200_OK)
        return HttpResponse(text, status= HTTP_200_OK)


@receiver(post_save, sender=UniversityCustomer)
def send_user(sender, instance, created, **kwargs):
    if created:
        username = instance.username
        exp = instance.service_until
        email = instance.login_email
        html_content = ("Hello,%s !<br>I noticed you've signed up to Upgrid."
                        "I just wanted to say thanks and to let you know we're here to answer any questions."
                        "<br>We genuinely value user feedback. So please don't hesitate to get in contact with"
                        "us at gt267127@gmail.com, even if it's just to say Hi! Or you can just reply to this emal"
                        "and one of the team will get back to you.<br>-Upgrid Team")
        message = EmailMessage(subject='welcome', body=html_content %(username,),
            to=[email])
        message.content_subtype = 'html'
        message.send()


@receiver(post_save, sender=UniversityCustomer)
def create_group(sender, instance, created, **kwargs):
    if created:
        if instance.account_type == 'main':
            mygroup, created = Group.objects.get_or_create(name='Primary' + instance.Ceeb.ceeb,)
            myuser = UniversityCustomer.objects.get(username=instance.username)
            myuser.groups.add(Group.objects.get(name='Primary' + instance.Ceeb.ceeb))
        elif instance.account_type == 'sub':
            mygroup, created = Group.objects.get_or_create(name='Sub' + instance.Ceeb.ceeb, )
            myuser = UniversityCustomer.objects.get(username=instance.username)
            myuser.groups.add(Group.objects.get(name='Sub' + instance.Ceeb.ceeb))
            mainUser = UniversityCustomer.objects.get(Ceeb=instance.Ceeb, account_type='main' )
            myuser.service_until = mainUser.service_until
            myuser.save()





#Upgrid New API Design
 